// Codegen worker: creates a minimal project scaffold and zips it.
// Usage (indirect): called by routes/generator.js
import fs from "fs-extra";
import path from "path";
import archiver from "archiver";
import Template from "../models/Template.js";
import Job from "../models/Job.js";

// Base output directory (placed next to the repo root)
const BASE_DIR = path.join(process.cwd(), "generated_projects");

function tsLog(message) {
  return `[${new Date().toISOString()}] ${message}`;
}
async function pushLog(job, line) {
  job.logs.push(tsLog(line));
  await job.save();
}
function safeSlug(s) {
  return String(s || "")
    .toLowerCase()
    .replace(/[^a-z0-9-_]+/g, "-")
    .replace(/^-+|-+$/g, "")
    .slice(0, 80) || "proj";
}

async function writeScaffold(projectDir, template) {
  const readme = `# ${template.title}

${template.description}

**Stack:** ${Array.isArray(template.stack) ? template.stack.join(", ") : ""}

## Getting started
\`\`\`bash
npm install
npm start
\`\`\`

Generated by SkillForge AI.
`;

  const pkg = {
    name: safeSlug(template.id || template.title || "skillforge-project"),
    version: "1.0.0",
    private: true,
    scripts: {
      start: "node index.js",
    },
    dependencies: {},
  };

  const indexJs = `console.log("ðŸš€ ${template.title} â€” starter scaffold running");\n`;

  await fs.outputFile(path.join(projectDir, "README.md"), readme);
  await fs.outputFile(
    path.join(projectDir, "package.json"),
    JSON.stringify(pkg, null, 2)
  );
  await fs.outputFile(path.join(projectDir, "index.js"), indexJs);
}

function zipDirectory(srcDir, outZipPath) {
  return new Promise((resolve, reject) => {
    const output = fs.createWriteStream(outZipPath);
    const archive = archiver("zip", { zlib: { level: 9 } });

    output.on("close", () => resolve());
    output.on("error", reject);
    archive.on("error", reject);

    archive.pipe(output);
    archive.directory(srcDir, false);
    archive.finalize();
  });
}

export async function runCodegenJob(jobId) {
  const job = await Job.findById(jobId);
  if (!job) throw new Error("Job not found");
  if (job.status === "processing") return;

  job.status = "processing";
  await pushLog(job, "Job started.");

  try {
    const template = await Template.findOne({ id: job.templateId });
    if (!template) {
      await pushLog(job, `Template not found: ${job.templateId}`);
      throw new Error("Template not found");
    }

    const userSlug = safeSlug(job.userId);
    const tplSlug = safeSlug(template.id);
    const projectDir = path.join(BASE_DIR, `${tplSlug}-${userSlug}`);

    await fs.ensureDir(BASE_DIR);
    await fs.emptyDir(projectDir); // clean previous run if any
    await pushLog(job, `Scaffolding into ${projectDir}`);

    await writeScaffold(projectDir, template);
    await pushLog(job, "Scaffold files written.");

    const zipPath = path.join(BASE_DIR, `${tplSlug}-${userSlug}.zip`);
    await zipDirectory(projectDir, zipPath);
    await pushLog(job, `ZIP created at ${zipPath}`);

    job.status = "done";
    job.artifactPath = path.relative(process.cwd(), zipPath);
    await pushLog(job, "Job finished successfully.");
    await job.save();

    return job.artifactPath;
  } catch (err) {
    job.status = "failed";
    await pushLog(job, `Error: ${err.message}`);
    await job.save();
    throw err;
  }
}
